# 计算机网络
---
[TOC]
## 1.网络分层
应用层：应用进程间的交互，完成特定网络应用，DNS,HTTP,HTTPS,FTP（数据的传输协议）
表示层：数据压缩，加密
会话层：建立，管理和弘治表示层与实体之间的通信会话（自动连接，自动网络寻址）
传输层：向两台主机中进程之间的通信提供数据传输服务,TCP,UDP（端口与端口的通信）
网络层：选择最佳路由传输路径，主机间的逻辑通信（计算机连接路径）
链路层：将网络层的数据包封装成帧，使用链路层协议在相邻节点间的链路上传输，保证两（路由）节点之间可靠的数据传输（规定0 1的分包形式）
物理层：相邻计算机节点之间比特流的透明传输，屏蔽传输介质和物理设备，（把数据转换成0 1）
## 2.TCP UDP 的区别
TCP是面向连接的，UDP是无连接的；
TCP是可靠的，UDP是不可靠的；
TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；
TCP是面向字节流的，UDP是面向报文的；
TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；
TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；
## 3.UDP 如何构建 TCP 的能力
## 4.TCP三次握手 四次挥手
### 三次握手
三次握手(我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功)
第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。
### 四次挥手
我要和你断开链接；好的，断吧。我也要和你断开链接；好的，断吧
第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。
第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。
### 为什么要三次握手
为了防止 已失效的链接请求报文突然又传送到了服务端，因而产生错误。
客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这是，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接。
### 为什么要四次挥手
TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”
### time_wait
#### time_wait出现在哪一阶段 哪一端
客户端收到服务器的关闭连接请求时，客户端进入time_wait状态
#### MSL
报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。
#### 等待2MSL的原因
保证TCP协议的全双工连接能够可靠关闭保证这次连接的重复数据段从网络中消失
第一点：如果主机1直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致主机2没有收到主机1最后回复的ACK。那么主机2就会在超时之后继续发送FIN，此时由于主机1已经CLOSED了，就找不到与重发的FIN对应的连接。所以，主机1不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。
第二点：如果主机1直接CLOSED，然后又再向主机2发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。
#### time_wait过多
TIME_WAIT 是主动关闭链接时形成的，等待2MSL时间，约4分钟。主要是防止最后一个ACK丢失。  由于TIME_WAIT的时间会非常长，因此server端应尽量减少主动关闭连接。
CLOSE_WAIT是被动关闭连接是形成的。根据TCP状态机，服务器端收到客户端发送的FIN，则按照TCP实现发送ACK，因此进入CLOSE_WAIT状态。但如果服务器端不执行close()，就不能由CLOSE_WAIT迁移到LAST_ACK，则系统中会存在很多CLOSE_WAIT状态的连接。此时，可能是系统忙于处理读、写操作，而未将已收到FIN的连接，进行close。此时，recv/read已收到FIN的连接socket，会返回0。
如果服务器出了异常，百分之八九十都是下面两种情况：
1.服务器保持了大量TIME_WAIT状态
2.服务器保持了大量CLOSE_WAIT状态，简单来说CLOSE_WAIT数目过大是由于被动关闭连接处理不当导致的。
因为linux分配给一个用户的文件句柄是有限的，而TIME_WAIT和CLOSE_WAIT两种状态如果一直被保持，那么意味着对应数目的通道就一直被占着，而且是“占着茅坑不使劲”，一旦达到句柄数上限，新的请求就无法被处理了，接着就是大量Too Many Open Files异常，Tomcat崩溃。

## 5.TCP 拥塞控制
慢启动：从小到大逐渐增加拥塞窗口的大小
拥塞避免：让拥塞窗口缓慢增长
快重传：接收方在收到一个失序的报文段后立即发出重复确认，发送方只要一连收到3个重复确认就立即重传对方未收到的报文段
快恢复：发送方一连收到3个重复确认，就执行乘法减小算法，把门限减半，但不执行慢开始算法
## 6.TCP 流量控制
防止分组丢失，实现TCP可靠传输
如果发送端发送数据太快，接收端来不及接收，就会丢包。为了避免丢包，就要控制发送端的发送速度。
由滑动窗口协议实现。滑动窗口协议保证了分组无差错，有序接收，流量控制。
滑动窗口协议：接收方每一次返回的ACK包中都会包含自己当前接收窗口的大小，让发送发发送不超过这个大小的数据包。
流量控制产生的死锁：发送端收到一个窗口为0的ACK，就停止发送数据，等待接收端把窗口增大。如果接收端窗口大于0的ACK在传输过程中丢失，发送端就会一直等待，接收端以为发送端收到了新的包，也会一直等待新数据的到来，双方相互等待，产生死锁。
避免流量控制死锁：持续计时器。当发送端收到一个0窗口的ACK，就启动持续计时器，计时器到了就主动发报文询问接收端新的窗口大小是多少。
## 7.TCP 可靠传输
## 8.浏览器输入域名后的步骤
## 9.子网掩码 私有地址
## 10.HTTP 常见状态码
## 11.HTTP 长连接 短链接
## 12.get post 的区别
## 13.网站攻击
## 14.攻击防范
## 15.CRC算法
## 16.一致性哈希
