# 数据库
---
## 索引
索引用来快速地寻找那些具有特定值的记录，所有MySQL索引都以B-树的形式保存。

优点

* 大大加快数据的检索速度;   
* 创建唯一性索引，保证数据库表中每一行数据的唯一性;   
* 加速表和表之间的连接;   
* 在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。

缺点

* 索引需要占用数据表以外的物理存储空间
* 创建索引和维护索引要花费一定的时间
* 当对表进行更新操作时，索引需要被重建，这样降低了数据的维护速度。
### 索引分类
#### 从逻辑角度
* 普通索引（单列索引）
* 唯一索引

此索引的每一个索引值只对应唯一的数据记录，对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复。

* 主键索引

主键索引是一种特殊的唯一索引，不允许有空值
* 全文索引

复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合
* 空间索引

空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。
MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。
创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建。
#### 从物理存储角度
* 聚集索引（clustered index）

按照数据存放的物理位置为顺序的，就像书中的目录，内容是按照页码顺序排列的。

将数据存储和索引放到了一块，找到了索引也就找到了数据；聚簇索引对主键查询有很高的性能，但是二级索引需要包含主键，因此索引会很大。

聚簇索引使用主键作为指针而不是地址值作为指针，好处在于牺牲了空间来保证在数据行移动的时候无需更新辅助索引中的主键。
行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行的记录时，如果已经被载入内存的话，便可以直接从内存中查找。速度快些。

* 非聚集索引（non-clustered index）

将数据存储与索引分开的结构，索引结构的叶子节点指向了数据的对应行。

*注意：一个表只能有一个聚集索引，但是可以由多个非聚集索引。
#### 从数据结构角度
* B+树索引(O(log(n)))

所有值（被索引的列）都是排过序的，每个叶节点到跟节点距离相等。
所以B-Tree适合用来查找某一范围内的数据，而且可以直接支持数据排序（ORDER BY）。但是当索引多列时，列的顺序特别重要，需要格外注意。
InnoDB和MyISAM都支持B-Tree索引。InnoDB用的是一个变种B+Tree，而MyISAM为了节省空间对索引进行了压缩，从而牺牲了性能。
* hash索引

仅能满足"=","IN"和"<=>"查询（只支持精确查找），不支持范围查找，不支持排序。这意味着范围查找或ORDER BY都要依赖server层的额外工作。
目前只有Memory引擎支持显式的hash索引（但是它的hash是nonunique的，冲突太多时也会影响查找性能）。
Memory引擎默认的索引类型即是Hash索引，虽然它也支持B-Tree索引。
其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，
所以 Hash 索引的查询效率要远高于 B-Tree 索引；只有Memory存储引擎显示支持hash索引。
* FULLTEXT索引

主要用来查找文本中的关键字，而不是直接与索引中的值相比较。
Full-text索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的WHERE语句的参数匹配。
你可以对某列分别进行full-text索引和B-Tree索引，两者互不冲突。
Full-text索引配合MATCH AGAINST操作使用，而不是一般的WHERE语句加LIKE。
* R-Tree索引

用于对GIS数据类型创建SPATIAL索引

### B树 B+树
#### B树（多路平衡查找树）
B树结
* 树中每个结点至多有m个孩子；
* 除根结点和叶子结点外，其它每个结点至少有[m\/2]个孩子；
* 若根结点不是叶子结点，则至少有2个孩子；
* 所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)；

B树搜索

* B树的整个关键字集合分布在整棵树上；
* 任何一个关键字出现且只出现在一个节点中；
* 搜索可能出现在非叶子节点结束；
* 其搜索性能等价于在关键字全集内做一次二分查找。

#### B+树
B树的变形，用于文件系统
* 有n棵子树的结点中含有n个关键字；
* 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。
* 所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。

优点
* 磁盘读写代价更低

B+树的内部结点并没有指向关键字具体信息的指针(比如文件内容的具体地址），因此其内部结点相对B~树更小。
如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。
这样，一次性读入内存中的需要查找的关键字也就越多。
* 查询效率更加稳定

由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。
所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

## 事务
原子性操作性(不可以分割的操作) - 要么全做, 要么全不做
### 事务的特点 ACID
* A - atomicity  原子性 : 不可分割, 要么成功要么全失败
* C - Consistency  一致性:  事务前后数据状态要保持一致, 总数一致
* I - Isolation  隔离性 : 多个事务不能看到对方的中间状态(提交或者回滚之前的状态)
* D - Duration  持久性: 事务完成后数据要持久化(事务的影响要反映在物理存储上)
### 事务的隔离模式
#### 可读未提交
写事务阻止其他写事务，避免更新遗失。
允许读事务，会出现脏读（读到中间数据）。
#### 可读已提交
写事务阻止读写事务。会出现不可重复读：在一次事务之间进行两次读取，但结果不一样（更新前和更新后）。
#### 可重复读
读事务会阻止其他写事务。
会出现幻读：阻止写事务的update和delete，但无法阻止insert（新行不存在，无法加锁），导致一次事务之间进行两次读取，记录条数不一样。
#### 序列化
读加共享锁，写加排他锁。读写，写写互斥。

### 操作方法
* begin; -开始事物
* commit; - 提交事物， Python 默认是取消自动提交的
* rollback; - 回撤操作, 只要操作没有执行 commit 就可以进行回滚操作, 撤回
* 直接用 SET 来改变 MySQL 的自动提交模式: SET AUTOCOMMIT=0 禁止自动提交；SET AUTOCOMMIT=1 开启自动提交
## 主从复制

## 锁

## 日志
### 日志分类
#### 普通日志
* 错误日志
* 慢查询日志
* 查询日志
#### 重点日志
* undo：用于事务回滚，将数据恢复到修改前的状态。InnoDB的多版本并发控制就是基于undo实现的。
* redo：重做日志，用来实现服务器异常时的数据恢复，实现事务的持久性。
* binlog：数据库的任何变化（create,update等），都以二进制文件的方式记录在主库的 binary log 日志文件中。

### binlog 的三种模式
* row

基于行的模式，记录行的变化。安全。但会比其他两种模式大很多，在一些表中清除大量数据时，会在 binlog 中生成很多语句，导致从库延迟变大。
* statement

基于SQL语句的模式，某些语句和函数如 UUID, LOAD DATA INFILE 等在复制过程中可能导致数据不一致甚至出错

* mixed

混合模式，根据语句来选择使用 row 还是 statement 模式
