# 数据库
---
## 索引
索引用来快速地寻找那些具有特定值的记录，所有MySQL索引都以B树的形式保存。

优点

* 大大加快数据的检索速度;   
* 创建唯一性索引，保证数据库表中每一行数据的唯一性;   
* 加速表和表之间的连接;   
* 在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。

缺点

* 索引需要占用数据表以外的物理存储空间
* 创建索引和维护索引要花费一定的时间
* 当对表进行更新操作时，索引需要被重建，这样降低了数据的维护速度。
### 索引分类
#### 从逻辑角度
* 普通索引（单列索引）
* 唯一索引

此索引的每一个索引值只对应唯一的数据记录，对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复。

* 主键索引

主键索引是一种特殊的唯一索引，不允许有空值
* 全文索引（覆盖索引）

复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合。

* 覆盖索引

当一条查询语句符合覆盖索引条件时，sql只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。
使用覆盖索引Innodb比MyISAM效果更好----InnoDB使用聚集索引组织数据，如果二级索引中包含查询所需的数据，就不再需要在聚集索引中查找了。

*注：遇到以下情况，执行计划不会选择覆盖查询
1. select选择的字段中含有不在索引中的字段 ，即索引没有覆盖全部的列。
2. where条件中不能含有对索引进行like的操作。

* 空间索引

空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。
MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。
创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建。
#### 从物理存储角度
* 聚集索引（clustered index）

按照数据存放的物理位置为顺序的，就像书中的目录，内容是按照页码顺序排列的。

将数据存储和索引放到了一块，找到了索引也就找到了数据；聚簇索引对主键查询有很高的性能，但是二级索引需要包含主键，因此索引会很大。

聚簇索引使用主键作为指针而不是地址值作为指针，好处在于牺牲了空间来保证在数据行移动的时候无需更新辅助索引中的主键。
行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行的记录时，如果已经被载入内存的话，便可以直接从内存中查找。速度快些。

* 非聚集索引（non-clustered index）

将数据存储与索引分开的结构，索引结构的叶子节点指向了数据的对应行。

*注意：一个表只能有一个聚集索引，但是可以由多个非聚集索引。*
#### 从数据结构角度
* B+树索引(O(log(n)))

所有值（被索引的列）都是排过序的，每个叶节点到跟节点距离相等。
所以B-Tree适合用来查找某一范围内的数据，而且可以直接支持数据排序（ORDER BY）。但是当索引多列时，列的顺序特别重要，需要格外注意。
InnoDB和MyISAM都支持B-Tree索引。InnoDB用的是一个变种B+Tree，而MyISAM为了节省空间对索引进行了压缩，从而牺牲了性能。
* hash索引

仅能满足"=","IN"和"<=>"查询（只支持精确查找），不支持范围查找，不支持排序。这意味着范围查找或ORDER BY都要依赖server层的额外工作。
目前只有Memory引擎支持显式的hash索引（但是它的hash是nonunique的，冲突太多时也会影响查找性能）。
Memory引擎默认的索引类型即是Hash索引，虽然它也支持B-Tree索引。
其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，
所以 Hash 索引的查询效率要远高于 B-Tree 索引；只有Memory存储引擎显示支持hash索引。
* FULLTEXT索引

主要用来查找文本中的关键字，而不是直接与索引中的值相比较。
Full-text索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的WHERE语句的参数匹配。
你可以对某列分别进行full-text索引和B-Tree索引，两者互不冲突。
Full-text索引配合MATCH AGAINST操作使用，而不是一般的WHERE语句加LIKE。
* R-Tree索引

用于对GIS数据类型创建SPATIAL索引

### B树 B+树
#### B树（多路平衡查找树）
B树结构
* 树中每个结点至多有m个孩子；
* 除根结点和叶子结点外，其它每个结点至少有[m\/2]个孩子；
* 若根结点不是叶子结点，则至少有2个孩子；
* 所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)；

B树搜索

* B树的整个关键字集合分布在整棵树上；
* 任何一个关键字出现且只出现在一个节点中；
* 搜索可能出现在非叶子节点结束；
* 其搜索性能等价于在关键字全集内做一次二分查找。

#### B+树
B树的变形，用于文件系统
* 有n棵子树的结点中含有n个关键字；
* 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。
* 所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。

优点
* 磁盘读写代价更低

B+树的内部结点并没有指向关键字具体信息的指针(比如文件内容的具体地址），因此其内部结点相对B~树更小。
如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。
这样，一次性读入内存中的需要查找的关键字也就越多。
* 查询效率更加稳定

由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。
所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

## 事务
原子性操作性(不可以分割的操作) - 要么全做, 要么全不做
### 事务的特点 ACID
* A - atomicity  原子性 : 不可分割, 要么成功要么全失败
* C - Consistency  一致性:  事务前后数据状态要保持一致, 总数一致
* I - Isolation  隔离性 : 多个事务不能看到对方的中间状态(提交或者回滚之前的状态)
* D - Duration  持久性: 事务完成后数据要持久化(事务的影响要反映在物理存储上)
### 事务的隔离模式
#### 可读未提交
写事务阻止其他写事务，避免更新遗失。
允许读事务，会出现脏读（读到中间数据）。
#### 可读已提交
写事务阻止读写事务。会出现不可重复读：在一次事务之间进行两次读取，但结果不一样（更新前和更新后）。
#### 可重复读
读事务会阻止其他写事务。
会出现幻读：阻止写事务的update和delete，但无法阻止insert（新行不存在，无法加锁），导致一次事务之间进行两次读取，记录条数不一样。
#### 序列化
读加共享锁，写加排他锁。读写，写写互斥。

### 操作方法
* begin; -开始事物
* commit; - 提交事物， Python 默认是取消自动提交的
* rollback; - 回撤操作, 只要操作没有执行 commit 就可以进行回滚操作, 撤回
* 直接用 SET 来改变 MySQL 的自动提交模式: SET AUTOCOMMIT=0 禁止自动提交；SET AUTOCOMMIT=1 开启自动提交

## 锁
SQL server的所有活动都会产生锁。锁定的单元越小，就越能越能提高并发处理能力，但是管理锁的开销越大。如何找到平衡点，使并发性和性能都可接受是SQL Server的难点。

### SQL Server 锁的分类
* 共享锁

用于只读操作(SELECT)，锁定共享的资源。共享锁不会阻止其他用户读，但是阻止其他的用户写和修改。
* 更新锁

更新锁是一种意图锁，当一个事物已经请求共享琐后并试图请求一个独占锁的时候发生更新琐。例如当两个事物在几行数据行上都使用了共享锁，并同时试图获取独占锁以执行更新操作时，就发生了死锁：都在等待对方释放共享锁而实现独占锁。更新锁的目的是只让一个事物获得更新锁，防止这种情况的发生。
* 独占锁（排它锁）

一次只能有一个独占锁用在一个资源上，并且阻止其他所有的锁包括共享缩。写是独占锁，可以有效的防止’脏读’
* 意图锁

在使用共享锁和独占锁之前，使用意图锁。从表的层次上查看意图锁，以判断事物能否获得共享锁和独占锁，提高了系统的性能，不需从页或者行上检查。
* 计划锁

Sch-M,Sch-S。对数据库结构改变时用Sch-M，对查询进行编译时用Sch-S。这两种锁不会阻塞任何事物锁，包括独占锁。

读是共享锁，写是独占锁（排它锁），先读后更新的操作是更新锁，更新锁成功并且改变了数据时更新锁升级到独占锁（排它锁）。

### 加锁协议
* 一级：事件在写之前必须加排它锁，直到事件完成后释放，脏读和不可重复读。
* 二级：事件在写之前必须加排它锁，直到事件完成才释放。在读之前必须加共享锁。读完成即可释放。不能保证可重复读。
* 三级：事件在写之前必须加排它锁，在读之前必须加共享锁，直到事件完成才释放。

### 两段锁协议
事物的智行可以分为两个阶段：生长阶段（加锁阶段）和衰退阶段（解锁阶段）。所有事物必须分为两个阶段对数据项进行加锁和解锁。
* 加锁阶段：在该阶段可以进行枷锁操作，在对热河数据进行读操作之前要申请并获得S锁，在进行写操作之前要申请并获得X锁。如果加锁不成功，则事务进入等待状态，直到加锁成功。
* 解锁阶段：当事务释放了一个封锁之后，事务进入解锁阶段，在该阶段只能进行解锁操作，不能加锁。

实现：事务开始后就处于加锁阶段，一直到执行rollback和commit，使事务进入解锁阶段。

### 防止死锁
（1）使用事务时，尽量缩短事务的逻辑处理过程，及早提交或回滚事务；

（2）设置死锁超时参数为合理范围，如：3分钟-10分种；超过时间，自动放弃本次操作，避免进程悬挂；

（3）所有的SP都要有错误处理（通过@error）；

（4）一般不要修改SQL SERVER事务的默认级别，不推荐强行加锁；

（5）优化程序，检查并避免死锁现象出现：
* 合理安排表访问顺序
* 在事务中尽量避免用户干预，尽量使一个事务处理的任务少些。
* 采用脏读技术。脏读由于不对被访问的表加锁，而避免了锁冲突。在客户机/服务器应用环境中，有些事务往往不允许读脏数据，但在特定的条件下，我们可以用脏读。
* 数据访问时域离散法。数据访问时域离散法是指在客户机/服务器结构中，采取各种控制手段控制对数据库或数据库中的对象访问时间段。主要通过以下方式实现: 合理安排后台事务的执行时间，采用工作流对后台事务进行统一管理。工作流在管理任务时，一方面限制同一类任务的线程数（往往限制为1个），防止资源过多占用; 另一方面合理安排不同任务执行时序、时间，尽量避免多个后台任务同时执行，另外，避免在前台交易高峰时间运行后台任务
* 数据存储空间离散法。数据存储空间离散法是指采取各种手段，将逻辑上在一个表中的数据分散到若干离散的空间上去，以便改善对表的访问性能。主要通过以下方法实现: 第一，将大表按行或列分解为若干小表; 第二，按不同的用户群分解。
* 使用尽可能低的隔离性级别。隔离性级别是指为保证数据库数据的完整性和一致性而使多用户事务隔离的程度，SQL92定义了4种隔离性级别：未提交读、提交读、可重复读和可串行。如果选择过高的隔离性级别，如可串行，虽然系统可以因实现更好隔离性而更大程度上保证数据的完整性和一致性，但各事务间冲突而死锁的机会大大增加，大大影响了系统性能。
* 使用Bound Connections。Bound connections 允许两个或多个事务连接共享事务和锁，而且任何一个事务连接要申请锁如同另外一个事务要申请锁一样，因此可以允许这些事务共享数据而不会有加锁的冲突。
* 考虑使用乐观锁定或使事务首先获得一个独占锁定。 

### 乐观锁 悲观锁
* 乐观锁

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。

适用于写比较少的情况下（多读场景），省去了锁的开销，加大了系统的整个吞吐量。

* 悲观锁

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

适合多写的情况。

#### 乐观锁实现机制
* 版本号机制

一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

* CAS算法

即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。

CAS算法涉及到三个操作数：

（1）需要读写的内存值 V

（2）进行比较的值 A

（3）拟写入的新值 B

当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。

#### 乐观锁的缺点
* ABA 问题

如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 "ABA"问题。
JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
* 循环时间长开销大

自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。
* 只能保证一个共享变量的原子操作

CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。

## 日志
### 日志分类
#### 普通日志
* 错误日志
* 慢查询日志
* 查询日志
#### 重点日志
* undo：用于事务回滚，将数据恢复到修改前的状态。InnoDB的多版本并发控制就是基于undo实现的。
* redo：重做日志，用来实现服务器异常时的数据恢复，实现事务的持久性。
* binlog：数据库的任何变化（create,update等），都以二进制文件的方式记录在主库的 binary log 日志文件中。

### binlog 的三种模式
* row

基于行的模式，记录行的变化。安全。但会比其他两种模式大很多，在一些表中清除大量数据时，会在 binlog 中生成很多语句，导致从库延迟变大。
* statement

基于SQL语句的模式，某些语句和函数如 UUID, LOAD DATA INFILE 等在复制过程中可能导致数据不一致甚至出错。

* mixed

混合模式，根据语句来选择使用 row 还是 statement 模式。

## 主从复制
### 主从数据库优点
* 备份，避免影响业务。从数据库(Slave)是主数据库的**备份**，当主数据库(Master)变化时从数据库要更新，可以设计更新周期。
* 实时灾备，用于故障切换，主从数据库服务器不在一个地理位置上，当发生意外时数据库可以保存。
* 读写分离，写操作集中在一个节点上，而读操作其其他的N个节点上进行，提高了读的效率，保证了系统的高可用性。
### 主从部署必要条件
* 主库开启binlog日志（设置log-bin参数）
* 主从server-id不同
* 从库服务器能连通主库

### 主从形式
* 一主一从
* 主主复制
* 一主多从
* 多主一从
* 联级复制

### 主从复制原理
* 在master机器上的操作

（1）当master上的数据发生变化时，该事件变化会按照顺序写入bin-log中。

（2）当slave链接到master的时候，master机器会为slave开启binlog dump线程。

（3）当master的binlog发生变化的时候，bin-log dump线程会通知slave，并将相应的binlog内容发送给slave。
* 在slave机器上操作sql线程

当主从同步开启的时候，slave上会创建两个线程：I\O线程和sql线程。

（1）I\O线程连接到master机器，master机器上的binlog dump 线程会将binlog的内容发送给该I\O线程。该I/O线程接收到binlog内容后，再将内容写入到本地的relay log。

（2）sql线程读取到I/O线程写入的ralay log，并且根据relay log 的内容对slave数据库做相应的操作。

### 主从复制模式
* 异步模式（MySQL默认）

主节点不会主动push bin log到从节点，这样有可能导致failover的情况下，也许从节点没有即时地将最新的bin log同步到本地。
* 半同步模式

主节点只需要接收到其中一台从节点的返回信息，就会commit；否则需要等待直到超时时间然后切换成异步模式再提交。

这样做的目的可以使主从数据库的数据延迟缩小，可以提高数据安全性，确保了事务提交后，binlog至少传输到了一个从节点上，不能保证从节点将此事务更新到db中。性能上会有一定的降低，响应时间会变长。
* 全同步模式

主节点和从节点全部执行了commit并确认才会向客户端返回成功。

## INNODB&& MyISAM
* 支持事务与不支持事务；
* 支持外键与不支持外键
* 支持行锁和支持表锁
* 查询速度慢与查询速度快
* 不支持全文索引和支持全文索引
