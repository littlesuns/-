# 数据库
---
## 索引
索引用来快速地寻找那些具有特定值的记录，所有MySQL索引都以B树的形式保存。

优点

* 大大加快数据的检索速度;   
* 创建唯一性索引，保证数据库表中每一行数据的唯一性;   
* 加速表和表之间的连接;   
* 在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。

缺点

* 索引需要占用数据表以外的物理存储空间
* 创建索引和维护索引要花费一定的时间
* 当对表进行更新操作时，索引需要被重建，这样降低了数据的维护速度。
### 索引分类
#### 从逻辑角度
* 普通索引（单列索引）

由关键字 key 或 index 定义的索引。允许包含重复的值。B树结构，时间复杂度 O(log n)。

应该职位哪些最经常出现在查询条件或排序条件中的数据列创建索引。如果有可能，应该选择一个数据最整齐，最紧凑的数据列来创建索引（如整数类型）。

* 唯一索引

用关键字 unique 定义。此索引的每一个索引值只对应唯一的数据记录，对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复。

新数据插入时，自动检查这个字段的值是否已经存在，如果存在则拒绝插入，保证数据记录的唯一性。

* 主键索引

用关键字 primary 定义。主键索引是一种特殊的唯一索引，不允许有空值。必须为主键字段创建一个主索引。

* 外键索引

如果为某个外键字段定义了一个外键约束，MySQL就会定义一个内部索引来帮助自己以最有效的方式去管理和使用外键约束。

* 联合索引

复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的前面的字段，索引才会被使用。使用复合索引时遵循最左前缀集合。比如在(a,b,c)三个字段上建立联合索引，那么它能够加快a|(a,b)|(a,b,c)三组查询的速度，而不能加快b|(b,a)这种查询顺序。

建联合索引的时候，区分度最高的字段在最左边。

* 覆盖索引

当一条查询语句符合覆盖索引条件时，sql只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。

使用覆盖索引Innodb比MyISAM效果更好----InnoDB使用聚集索引组织数据，如果二级索引中包含查询所需的数据，就不再需要在聚集索引中查找了。

*注：遇到以下情况，执行计划不会选择覆盖查询*
1. select选择的字段中含有不在索引中的字段 ，即索引没有覆盖全部的列。
2. where条件中不能含有对索引进行like的操作。

* 空间索引

空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。
MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。
创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建。

#### 从物理存储角度
* 聚集索引（clustered index）

按照数据存放的物理位置为顺序的，就像书中的目录，内容是按照页码顺序排列的。

将数据存储和索引放到了一块，找到了索引也就找到了数据；聚簇索引对主键查询有很高的性能，但是二级索引需要包含主键，因此索引会很大。

聚簇索引使用主键作为指针而不是地址值作为指针，好处在于牺牲了空间来保证在数据行移动的时候无需更新辅助索引中的主键。
行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行的记录时，如果已经被载入内存的话，便可以直接从内存中查找。速度快些。

* 非聚集索引（non-clustered index）

将数据存储与索引分开的结构，索引结构的叶子节点指向了数据的对应行。

*注意：一个表只能有一个聚集索引，但是可以由多个非聚集索引。*
#### 从数据结构角度
* B+树索引(O(log(n)))

所有值（被索引的列）都是排过序的，每个叶节点到跟节点距离相等。
所以B-Tree适合用来查找某一范围内的数据，而且可以直接支持数据排序（ORDER BY）。但是当索引多列时，列的顺序特别重要，需要格外注意。
InnoDB和MyISAM都支持B-Tree索引。InnoDB用的是一个变种B+Tree，而MyISAM为了节省空间对索引进行了压缩，从而牺牲了性能。
* hash索引

仅能满足"=","IN"和"<=>"查询（只支持精确查找），不支持范围查找，不支持排序。这意味着范围查找或ORDER BY都要依赖server层的额外工作。
目前只有Memory引擎支持显式的hash索引（但是它的hash是nonunique的，冲突太多时也会影响查找性能）。
Memory引擎默认的索引类型即是Hash索引，虽然它也支持B-Tree索引。
其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，
所以 Hash 索引的查询效率要远高于 B-Tree 索引；只有Memory存储引擎显示支持hash索引。
* FULLTEXT索引

主要用来查找文本中的关键字，而不是直接与索引中的值相比较。
Full-text索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的WHERE语句的参数匹配。
你可以对某列分别进行full-text索引和B-Tree索引，两者互不冲突。
Full-text索引配合MATCH AGAINST操作使用，而不是一般的WHERE语句加LIKE。
* R-Tree索引

用于对GIS数据类型创建SPATIAL索引

#### 主键索引 唯一索引 的区别
* 主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。
* 主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。
* 主键列不允许为空值，唯一性索引列允许空值。主键列在创建时，已经默认为空值 + 唯一索引了。
* 主键可以被其他表引用为外键，而唯一索引不能。
* 一个表最多只能创建一个主键，但可以创建多个唯一索引。
* 主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等。
* 在 RBO 模式下，主键的执行计划优先级要高于唯一索引。 两者可以提高查询的速度。
* 主键不一定只包含一个字段，所以如果你在主键的其中一个字段建唯一索引还是必要的。

### B树 B+树
#### B树（多路平衡查找树）
B树结构
* 树中每个结点至多有m个孩子；
* 除根结点和叶子结点外，其它每个结点至少有[m\/2]个孩子；
* 若根结点不是叶子结点，则至少有2个孩子；
* 所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)；

B树搜索

* B树的整个关键字集合分布在整棵树上；
* 任何一个关键字出现且只出现在一个节点中；
* 搜索可能出现在非叶子节点结束；
* 其搜索性能等价于在关键字全集内做一次二分查找。

#### B+树
B树的变形，用于文件系统
* 有n棵子树的结点中含有n个关键字；
* 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。
* 所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。

优点
* 磁盘读写代价更低

B+树的内部结点并没有指向关键字具体信息的指针(比如文件内容的具体地址），因此其内部结点相对B~树更小。
如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。
这样，一次性读入内存中的需要查找的关键字也就越多。
* 查询效率更加稳定

由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。
所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

### 索引优化

#### 不要在列上使用函数和进行运算
这将导致索引失效而进行全表扫描。
```
select * from artile where YEAR(create_time) <= '2018'; 
```
即使 date 上建立了索引，也会全表扫描，可以把计算放到业务层，这样做不仅可以节省数据库的 CPU，还可以起到查询缓存优化效果。

#### 负向条件查询不能使用索引
负向条件有：!=、<>、not in、not exists、not like 等。可以使用in进行优化。
```
select * from artile where status != 1 and status != 2;
select * from artile where status in (0,3)
```
#### 使用覆盖索引
数据能从索引中取得，而不用通过行定位符再到数据表上获取，能够极大的提高性能。可以定义一个让索引包含的额外的列，即使这个列对于索引而言是无用的。

#### 避免强制类型转换
当查询条件左右两侧类型不匹配的时候会发生强制转换，强制转换可能导致索引失效而进行全表扫描。
```
//如果phone字段是varchar类型，则下面的SQL不能命中索引：
select * from user where phone=12345678901;
//可以优化为：
select * from user where phone='12345678901';
```

#### 范围列可以用到索引
范围条件有：<、<=、>、>=、between等。

范围列可以用到索引，但是范围列后面的列无法用到索引，索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引。

#### 更新频繁、数据区分度不高的字段上不宜建立索引
更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能。

「性别」这种区分度不大的属性，建立索引没有意义，不能有效过滤数据，性能与全表扫描类似。区分度可以使用 count(distinct(列名))/count(\*) 来计算，在80%以上的时候就可以建立索引。

#### 索引列不允许为null
单列索引不存null值，复合索引不存全为null的值，如果列允许为 null，可能会得到不符合预期的结果集。

#### 避免使用or来连接条件
应该尽量避免在 where 子句中使用 or 来连接条件，因为这会导致索引失效而进行全表扫描，虽然新版的MySQL能够命中索引，但查询优化耗费的 CPU比in多。

#### 模糊查询
前导模糊查询不能使用索引，非前导查询可以。

#### 如果明确知道只有一条结果返回，limit 1 能够提高效率
虽然自己知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动。

## 事务
原子性操作性(不可以分割的操作) - 要么全做, 要么全不做
### 事务的特点 ACID
* A - atomicity  原子性 : 不可分割, 要么成功要么全失败
* C - Consistency  一致性:  事务前后数据状态要保持一致, 总数一致
* I - Isolation  隔离性 : 多个事务不能看到对方的中间状态(提交或者回滚之前的状态)
* D - Duration  持久性: 事务完成后数据要持久化(事务的影响要反映在物理存储上)
### 事务的隔离模式
#### 可读未提交
写事务阻止其他写事务，避免更新遗失。
允许读事务，会出现脏读（读到中间数据）。
#### 可读已提交
写事务阻止读写事务。会出现不可重复读：在一次事务之间进行两次读取，但结果不一样（更新前和更新后）。
#### 可重复读
读事务会阻止其他写事务。
会出现幻读：阻止写事务的update和delete，但无法阻止insert（新行不存在，无法加锁），导致一次事务之间进行两次读取，记录条数不一样。
#### 序列化
读加共享锁，写加排他锁。读写，写写互斥。

### 操作方法
* begin; -开始事物
* commit; - 提交事物， Python 默认是取消自动提交的
* rollback; - 回撤操作, 只要操作没有执行 commit 就可以进行回滚操作, 撤回
* 直接用 SET 来改变 MySQL 的自动提交模式: SET AUTOCOMMIT=0 禁止自动提交；SET AUTOCOMMIT=1 开启自动提交

## 锁
SQL server的所有活动都会产生锁。锁定的单元越小，就越能越能提高并发处理能力，但是管理锁的开销越大。如何找到平衡点，使并发性和性能都可接受是SQL Server的难点。

### SQL Server 锁的分类
* 共享锁

用于只读操作(SELECT)，锁定共享的资源。共享锁不会阻止其他用户读，但是阻止其他的用户写和修改。
* 更新锁

更新锁是一种意图锁，当一个事物已经请求共享琐后并试图请求一个独占锁的时候发生更新琐。例如当两个事物在几行数据行上都使用了共享锁，并同时试图获取独占锁以执行更新操作时，就发生了死锁：都在等待对方释放共享锁而实现独占锁。更新锁的目的是只让一个事物获得更新锁，防止这种情况的发生。
* 独占锁（排它锁）

一次只能有一个独占锁用在一个资源上，并且阻止其他所有的锁包括共享缩。写是独占锁，可以有效的防止’脏读’
* 意图锁

在使用共享锁和独占锁之前，使用意图锁。从表的层次上查看意图锁，以判断事物能否获得共享锁和独占锁，提高了系统的性能，不需从页或者行上检查。
* 计划锁

Sch-M,Sch-S。对数据库结构改变时用Sch-M，对查询进行编译时用Sch-S。这两种锁不会阻塞任何事物锁，包括独占锁。

读是共享锁，写是独占锁（排它锁），先读后更新的操作是更新锁，更新锁成功并且改变了数据时更新锁升级到独占锁（排它锁）。

### 加锁协议
* 一级：事件在写之前必须加排它锁，直到事件完成后释放，脏读和不可重复读。
* 二级：事件在写之前必须加排它锁，直到事件完成才释放。在读之前必须加共享锁。读完成即可释放。不能保证可重复读。
* 三级：事件在写之前必须加排它锁，在读之前必须加共享锁，直到事件完成才释放。

### 两段锁协议
事物的智行可以分为两个阶段：生长阶段（加锁阶段）和衰退阶段（解锁阶段）。所有事物必须分为两个阶段对数据项进行加锁和解锁。
* 加锁阶段：在该阶段可以进行枷锁操作，在对热河数据进行读操作之前要申请并获得S锁，在进行写操作之前要申请并获得X锁。如果加锁不成功，则事务进入等待状态，直到加锁成功。
* 解锁阶段：当事务释放了一个封锁之后，事务进入解锁阶段，在该阶段只能进行解锁操作，不能加锁。

实现：事务开始后就处于加锁阶段，一直到执行rollback和commit，使事务进入解锁阶段。

### 防止死锁
（1）使用事务时，尽量缩短事务的逻辑处理过程，及早提交或回滚事务；

（2）设置死锁超时参数为合理范围，如：3分钟-10分种；超过时间，自动放弃本次操作，避免进程悬挂；

（3）所有的SP都要有错误处理（通过@error）；

（4）一般不要修改SQL SERVER事务的默认级别，不推荐强行加锁；

（5）优化程序，检查并避免死锁现象出现：
* 合理安排表访问顺序
* 在事务中尽量避免用户干预，尽量使一个事务处理的任务少些。
* 采用脏读技术。脏读由于不对被访问的表加锁，而避免了锁冲突。在客户机/服务器应用环境中，有些事务往往不允许读脏数据，但在特定的条件下，我们可以用脏读。
* 数据访问时域离散法。数据访问时域离散法是指在客户机/服务器结构中，采取各种控制手段控制对数据库或数据库中的对象访问时间段。主要通过以下方式实现: 合理安排后台事务的执行时间，采用工作流对后台事务进行统一管理。工作流在管理任务时，一方面限制同一类任务的线程数（往往限制为1个），防止资源过多占用; 另一方面合理安排不同任务执行时序、时间，尽量避免多个后台任务同时执行，另外，避免在前台交易高峰时间运行后台任务
* 数据存储空间离散法。数据存储空间离散法是指采取各种手段，将逻辑上在一个表中的数据分散到若干离散的空间上去，以便改善对表的访问性能。主要通过以下方法实现: 第一，将大表按行或列分解为若干小表; 第二，按不同的用户群分解。
* 使用尽可能低的隔离性级别。隔离性级别是指为保证数据库数据的完整性和一致性而使多用户事务隔离的程度，SQL92定义了4种隔离性级别：未提交读、提交读、可重复读和可串行。如果选择过高的隔离性级别，如可串行，虽然系统可以因实现更好隔离性而更大程度上保证数据的完整性和一致性，但各事务间冲突而死锁的机会大大增加，大大影响了系统性能。
* 使用Bound Connections。Bound connections 允许两个或多个事务连接共享事务和锁，而且任何一个事务连接要申请锁如同另外一个事务要申请锁一样，因此可以允许这些事务共享数据而不会有加锁的冲突。
* 考虑使用乐观锁定或使事务首先获得一个独占锁定。 

### 乐观锁 悲观锁
* 乐观锁

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。

适用于写比较少的情况下（多读场景），省去了锁的开销，加大了系统的整个吞吐量。

* 悲观锁

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

适合多写的情况。

#### 乐观锁实现机制
* 版本号机制

一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

* CAS算法

即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。

CAS算法涉及到三个操作数：

（1）需要读写的内存值 V

（2）进行比较的值 A

（3）拟写入的新值 B

当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。

#### 乐观锁的缺点
* ABA 问题

如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 "ABA"问题。
JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
* 循环时间长开销大

自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。
* 只能保证一个共享变量的原子操作

CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。

## 日志
### 日志分类
#### 普通日志
* 错误日志
* 慢查询日志
* 查询日志
#### 重点日志
* undo：用于事务回滚，将数据恢复到修改前的状态。InnoDB的多版本并发控制就是基于undo实现的。
* redo：重做日志，用来实现服务器异常时的数据恢复，实现事务的持久性。
* binlog：数据库的任何变化（create,update等），都以二进制文件的方式记录在主库的 binary log 日志文件中。

### binlog 的三种模式
* row

基于行的模式，记录行的变化。安全。但会比其他两种模式大很多，在一些表中清除大量数据时，会在 binlog 中生成很多语句，导致从库延迟变大。
* statement

基于SQL语句的模式，某些语句和函数如 UUID, LOAD DATA INFILE 等在复制过程中可能导致数据不一致甚至出错。

* mixed

混合模式，根据语句来选择使用 row 还是 statement 模式。

## 主从复制
### 主从数据库优点
* 备份，避免影响业务。从数据库(Slave)是主数据库的**备份**，当主数据库(Master)变化时从数据库要更新，可以设计更新周期。
* 实时灾备，用于故障切换，主从数据库服务器不在一个地理位置上，当发生意外时数据库可以保存。
* 读写分离，写操作集中在一个节点上，而读操作其其他的N个节点上进行，提高了读的效率，保证了系统的高可用性。
### 主从部署必要条件
* 主库开启binlog日志（设置log-bin参数）
* 主从server-id不同
* 从库服务器能连通主库

### 主从形式
* 一主一从
* 主主复制
* 一主多从
* 多主一从
* 联级复制

### 主从复制原理
* 在master机器上的操作

（1）当master上的数据发生变化时，该事件变化会按照顺序写入bin-log中。

（2）当slave链接到master的时候，master机器会为slave开启binlog dump线程。

（3）当master的binlog发生变化的时候，bin-log dump线程会通知slave，并将相应的binlog内容发送给slave。
* 在slave机器上操作sql线程

当主从同步开启的时候，slave上会创建两个线程：I\O线程和sql线程。

（1）I\O线程连接到master机器，master机器上的binlog dump 线程会将binlog的内容发送给该I\O线程。该I/O线程接收到binlog内容后，再将内容写入到本地的relay log。

（2）sql线程读取到I/O线程写入的ralay log，并且根据relay log 的内容对slave数据库做相应的操作。

### 主从复制模式
* 异步模式（MySQL默认）

主节点不会主动push bin log到从节点，这样有可能导致failover的情况下，也许从节点没有即时地将最新的bin log同步到本地。
* 半同步模式

主节点只需要接收到其中一台从节点的返回信息，就会commit；否则需要等待直到超时时间然后切换成异步模式再提交。

这样做的目的可以使主从数据库的数据延迟缩小，可以提高数据安全性，确保了事务提交后，binlog至少传输到了一个从节点上，不能保证从节点将此事务更新到db中。性能上会有一定的降低，响应时间会变长。
* 全同步模式

主节点和从节点全部执行了commit并确认才会向客户端返回成功。

## INNODB&& MyISAM
* 支持事务与不支持事务；
* 支持外键与不支持外键
* 支持行锁和支持表锁
* 查询速度慢与查询速度快
* 不支持全文索引和支持全文索引

## 缓存
### Redis
Redis是一个开源的,底层使用C语言编写的 key-value 存储数据库。可用于缓存、事件发布订阅、高速队列等场景。而且支持丰富的数据类型：string(字符串)、hash(哈希)、list(列表)、set(无序集合)、zset(sorted set：有序集合)。

### 应用场景
* 缓存数据：最常用，对经常需要查询且变动不是很频繁的数据，常称作热点数据。
* 消息队列：相当于消息订阅系统，比如ActiveMQ、RocketMQ。如果对数据有较高一致性要求时，还是建议使用MQ)。
* 计数器：比如统计点击率、点赞率，redis具有原子性，可以避免并发问题。
* 电商网站信息：大型电商平台初始化页面数据的缓存。比如去哪儿网购买机票的时候首页的价格和你点进去的价格会有差异。
* 热点数据：比如新闻网站实时热点、微博热搜等，需要频繁更新。总数据量比较大的时候直接从数据库查询会影响性能。

客户端->数据库层->缓存-> MySQL

#### Redis 数据结构
* String：字符串是最常用的数据类型，他能够存储任何类型的字符串，当然也包括二进制、JSON化的对象、甚至是base64编码之后的图片。在Redis中一个字符串最大的容量为512MB，可以说是无所不能了。
* Hash：常用作存储结构化数据、比如论坛系统中可以用来存储用户的Id、昵称、头像、积分等信息。如果需要修改其中的信息，只需要通过Key取出Value进行反序列化修改某一项的值，再序列化存储到Redis中，Hash结构存储，由于Hash结构会在单个Hash元素在不足一定数量时进行压缩存储，所以可以大量节约内存。这一点在String结构里是不存在的。
* List：List的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis 内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。另外，可以利用 lrange 命令，做基于 Redis 的分页功能，性能极佳，用户体验好。
* Set：set 对外提供的功能与 list 类似是一个列表的功能，特殊之处在于 set 是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，这个时候就可以选择使用set。
* Sort Set：可以按照某个条件的权重进行排序，比如可以通过点击数做出排行榜的数据应用。

#### Redis 缓存数据一致性
缓存只能做到最终一致，无法做到强一致。

#### Redis的过期策略
* 定期删除：默认是每100ms检测一次，遇到过期的key则进行删除。检测并不是顺序检测，而是随机检测。
* 惰性过期：当我们去读/写一个已经过期的key时，会触发Redis的惰性删除策略，直接删除过期的key。

#### Redis的内存淘汰策略
* noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。
* allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。
* allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
* volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
* volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
* volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。
#### 缓存穿透
请求去查询一条数据库中不存在的数据，缓存和数据库都查询不到这条数据，但每次都会访问数据库。

黑客利用缓存穿透进行系统攻击，导致数据库宕机。

解决方案：
* 设置缓存空值。不存在的key的值都设置成null放在缓存里。注意设置过期时间。
* 提供一个拦截机制，内部维护一系列合法的key值。当请求的key不合法时，直接返回。
* 布隆过滤器。在缓存之前加一层布隆过滤器，判断某个元素是否存在。

缓存击穿
由于 key 失效，导致缓存中查不到，导致大量数据库访问。
* 互斥锁。多线程同时访问时，利用互斥锁，只允许第一个线程访问数据库，并同时更新缓存。后面的访问就可以通过缓存获得，不用再访问数据库。
* 后台设置定时任务，主动的去更新缓存数据。这种方案容易理解，但是当key比较分散的时候，操作起来还是比较复杂的。
* 分级缓存。比如设置两层缓存保护层，1级缓存失效时间短，2级缓存失效时间长。有请求过来优先从1级缓存中去查找，如果在1级缓存中没有找到相应数据，则对该线程进行加锁，这个线程再从数据库中取到数据，更新至1级和2级缓存。其他线程则直接从2级线程中获取。

#### 缓存雪崩
缓存雪崩就是指缓存由于某些原因（比如 宕机、cache服务挂了或者不响应）整体crash掉了，导致大量请求到达后端数据库，从而导致数据库崩溃，整个系统崩溃，发生灾难。

* 事前：使用集群缓存，保证缓存服务的高可用。可以使用 主从+哨兵 ，Redis Cluster 来避免 Redis 全盘崩溃的情况。
* 事中：ehcache本地缓存 + Hystrix限流&降级,避免MySQL被打死。在 Redis Cluster 完全不可用的时候，使用 ehcache 本地缓存暂时替代。使用 Hystrix进行限流 & 降级 ，比如一秒来了5000个请求，我们可以设置假设只能有一秒 2000个请求能通过这个组件，那么其他剩余的 3000 请求就会走限流逻辑。然后去调用我们自己开发的降级组件（降级），比如设置的一些默认值之类的，避免宕机。
* 事后：开启Redis持久化机制，尽快恢复缓存集群。

#### Redis 优点
* Redis是纯内存操作，需要的时候需要我们手动持久化到硬盘中。
* Redis是单线程，从而避开了多线程中上下文频繁切换的操作。
* Redis数据结构简单、对数据的操作也比较简单。
* 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
* 使用多路I/O复用模型，非阻塞I/O。

#### Redis 缺点
* 于是内存数据库，所以单台机器存储的数据量是有限的，需要开发者提前预估，需要及时删除不需要的数据。
* 当修改Redis的数据之后需要将持久化到硬盘的数据重新加入到内容中，时间比较久，这个时候Redis是无法正常运行的。
