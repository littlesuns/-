# C++
---
## 三大特性
* 封装

把客观事物封装成抽象的类，把自己的数据和方法只让可信的类或者对象操作，对不可信的类或者对象进行**信息隐藏**。

对象对内部数据提供了**不同级别的保护**，防止程序对数据进行错误的操作。

* 继承

使用已有的对象作为基类，在此基础上派生出新类。派生类可以复用基类的功能，也可以扩展，实现代码复用。可以通过继承和组合来实现。
## 实现方式
* 实现继承

直接使用基类的属性和方法，无需额外编码的能力

* 接口继承

仅使用属性和方法的名称，但是子类必须提供实现的能力

* 多态
## 多态
一个类实例的相同方法在不同情形下有不同的表现形式。分为编译时多态和运行时多态。编译时多态叫做重载，运行时多态主要指动态绑定。基类的指针和引用可以调用派生类的指针或引用。
### 多态的实现方式
* 静态多态

同名函数，不同参数，编译器会根据实参类型来选择调用合适的函数，如果没有合适的函数就会发出警告或者报错。
* 动态多态

类，虚函数。

当类中存在虚函数，编译器会在类中自动生成一个虚函数表，虚函数表是一个存储类成员函数指针的数据结构。

virtual修饰的成员函数会被编译器放入虚函数表。

编译器会为对象自动生成一个指向虚函数表的指针（vptr指针）。

当我们传入父类对象时，将调用和执行父类的函数，当我们传入子类对象时，将调用和执行子类的函数。

而 C++ 编译器的执行过程其实是这样的：
父类的 fun() 是个虚函数，所以编译器给父类对象自动添加了一个 vptr 指针，指向父类的虚函数表，
这个虚函数表里存放了父类的 fun() 函数的函数指针。

子类的 fun() 函数是重写了父类的，即写不写 virtual 编译器都会为其自动添加一个 virtual，
然后编译器给子类对象自动添加了一个 vptr 指针，指向子类的虚函数表，这个虚函数表里存放了子类的 fun() 函数的函数指针。

执行 p->fun() 时，编译器检测到 fun() 是一个虚函数，所以不会静态的将 Parent 类的 fun() 方法直接编译过来，
而是是运行的时候，动态的根据 base 指向的对象，找到这个对象的 vptr 指针，然后找到这个对象的虚函数表，
最后调用虚函数表里对应的函数，实现多态。

### 如何证明vptr的存在
* 存在vptr的类，size增加了4个字节
* 父类的构造方法中调用虚函数，不会发生多态

### vptr 的分步初始化
在父类中调用虚函数时，执行的还是父类的函数，没有发生多态。这是因为当创建子类对象时，编译器的执行顺序其实是这样的：
* 对象在创建时，由编译器对 vptr 进行初始化
* 子类的构造会先调用父类的构造函数，这个时候 vptr 会先指向父类的虚函数表
* 子类构造的时候，vptr 会再指向子类的虚函数表
* 对象的创建完成后，vptr 最终的指向才确定

### 构造函数中调用虚函数
* 当在构造函数中调用虚函数时，虚函数表现为该类中虚函数的行为，即父类构造函数调用虚函数，则虚函数为父类中的虚函数；
子类构造函数中调用虚函数，则调用的是子类中的虚函数；
* 如果不是在构造函数中调用虚函数，则会首先查看虚函数表，如果有实例实现，则调用实例。
比如：父类中有虚函数watchTv，则调用父类中watchTv时，则因为子类实现了watchTv，则调用子类的watchTv。

### 虚继承
一个指定的基类，在继承体系结构中，将其成员数据实例共享给也从这个基类型直接或间接派生的其它类。这一概念一般用于“继承”在表现为一个整体，而非几个部分的组合时。在C++中，基类可以通过使用关键字virtual来声明虚继承关系。
#### 菱形继承
假如类A和类B各自从类X派生（非虚继承且假设类X包含一些数据成员），且类C同时多继承自类A和B，那么C的对象就会拥有两套X的实例数据（可分别独立访问，一般要用适当的消歧义限定符），产生多重继承歧义。
#### 虚继承解决多重继承歧义
如果类A与B各自虚继承了类X，那么C的对象就只包含一套类X的实例数据，避免由于带有歧义的组合而产生的问题。其原理是，间接派生类（C）穿透了其父类（上面例子中的A与B），实质上直接继承了虚基类X。
```
class A
{
public:
	A():a(1){};
	void printA(){cout<<a<<endl;}
	int a;
};
 
class B : virtual public A
{
};
 
class C : virtual public A
{
};
 
class D:  public B ,  public C
{
};
 
int _tmain(int argc, _TCHAR* argv[])
{
	D d;
	cout<<sizeof(d);
	d.a=10;
	d.printA();

```

## 指针和引用
* 指针

是一个存储地址的变量，指向内存的一个存储单元
* 引用

原变量的别名，和原变量是同一个东西
```
int a=1;int *p=&a;
int a=1;int &b=a;
```
### 区别
* 指针是一个存储变量地址的变量，引用是变量的别名；
* 可以有const指针，但是没有const引用；
* 指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）
* 指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；
* 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了；
* "sizeof引用"得到的是所指向的变量(对象)的大小，而"sizeof指针"得到的是指针本身的大小；
* 指针和引用的自增(++)运算意义不一样。

## 内存分配 new malloc
### new 和 malloc 的区别
* new

是一个操作符，它也可以完成分配一段内存空间的功能，除此之外，它还会对内存空间进行初始化，调用构造函数
是一个函数，可以分配一段内存空间，并返回地址的指针
* malloc

是一个函数，可以分配一段内存空间，并返回地址的指针
### malloc 底层机制
malloc 采用了**内存池**的方式来减少内存碎片和系统调用的开销。

先申请大块内存作为堆区，然后将堆分成许多内存块，以块为内存管理的基本单位。Malloc通过**隐式链表结构**来管理所有的空闲块，即用一个双向链表将空闲块连接起来，每一个空闲块记录里一个连续的未分配的地址。

当用户申请内存的时候，直接从堆区分配出一块适合的空闲块。当进行内存分配的时候，Malloc 会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配。Malloc 在申请内存的时候，一般会通过**brk 和 Mmap** 系统调用进行申请。当内存数量小128k采用前者，否则采用后者。

当进行内存合并的时候，malloc 采用**边界标记法**，根据每个块是否已经分配来决定是否进行块合并。
* 前后都已被占用：直接插入内存块
* 前后至少有一个没有被占用：先合并再插入

## 智能指针
### 为什么要用智能指针
malloc/new的缺陷：
* 手动malloc/new出来的资源，容易忘记free/delete
* 影响执行流的地方需要注意释放释放资源，容易导致资源泄漏（如free/delete在return之后）
* 中途抛出异常，无法释放资源。如：int*p1=new int；int*p2=new int [10000000]；delete p1;
delele [ ] p2;因为p2new的内存比较大，万一new失败，则导致p1永远无法释放。

创建一份资源出来的时候，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源。
除此之外，通过运算符重载（重载*和重在->等），可以向指针一样使用。

## 强制转换
### const_cast
常量指针/引用被转换成非常量的指针/引用，并指向原来的对象。
使用它来去除const引用对象的const，完成函数调用。
结合static_cast，在非const版本的成员函数中添加const，调用完const版本的成员函数后，再使用const_cast去除const限定
### static_cast
有没有运行时类型检查来保证转换的安全性，所以有安全隐患
类层次结构中基类和派生类之间指针或引用的转换。上行转换（派生类的指针转换成基类表示）是安全的，下行转换是不安全的
基本数据类型之间的转换，这种转换的安全性需要开发者来维护
C++的任何的隐式转换都是使用static_cast实现的
static_cast不能转换掉原有类型的const，volatile，_unaligned属性，但前两者可以使用const_cast去除
### dynamic_cast
存在虚函数的父子关系的强制类型转换，对于指针，转换失败返回nullptr，对于引用，失败会抛出异常
### reinterpret_cast
处理任意类型的指针之间的转换，指针转向足够大的整型，整形转成指针，指向函数的指针指向另一个不同类型的指向函数的指针，
指向对象的指针转向另一个不同类型的指向对象的指针，指向成员的指针指向另一个指向成员的指针

## 堆和栈的区别
存储内容
系统响应
内存限制
申请效率
存取效率
### 定义只能在堆/栈上生成的对象
#### 只能在堆上
方法：将析构函数设置为私有

原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。
若析构函数不可访问，则不能在栈上创建对象。
#### 只能在栈上
方法：将 new 和 delete 重载为私有

原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；
第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。

## 模板 泛型
为了做基于类型和常量的编译时多态

编译时多态类型：
* 模板
* 函数（操作符）重载--动态多态
* 模板特化：全特化-特化后不再有模板参数，部分特化-特化后仍然有模板参数
* duck typing：基于特征的多态方式
## 字节
### 字节序
储存数据的方式：大端字节序（高位在前，低位在后），小端字节序（高位在后，低位在前）

为什么会有小端字节序：计算机电路先处理低位字节，效率高，因为计算都是从低位开始。

所以计算机内部可能会用小端字节序（X86是小字节序）(不知道能不能改变）

什么时候用大端字节序：网络传输和文件存储。符合人类读写习惯
### 字节对齐
计算机存储系统以byte为单位存储数据，不同数据类型所占空间不同。默认情况下将数据存放在某个地址的起始位置，这个地址能够被数据类型大小整除。
例如int的起始地址能被4整除。
结构体变量的首地址能够被其最宽基本类型成员的大小所整除；
结构体每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节（internal padding）；
结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）。
便于计算机快速读写数据。
```
struct student{char name[5],int num,short score;}=>16字节
struct student{nt num,char name[5],short score;}=>12字节
```
可以使用pragma pack（2），手动设置数据类型大小大于2的都按2字节对齐

## STL
### STL容器的底层数据结构及时间复杂度
* vector->数组，O(1)时间访问，顺序存储，扩容规则：初始分配连续内存空间，空间满后重新申请2倍内存空间，拷贝，释放原空间
* list->双向链表
* deque->中央控制器+多个缓冲区，支持首尾快速增删，支持随机访问
* stack->list或者deque
* queue->list或者deque
* priority_queue->vector为底层容器，heap为处理规则，O(1)取出最大最小元素，O(lgn)插入和删除
* set->红黑树，有序，不重复，只保存key，不保存value
* multiset->红黑树，有序，可重复
* map->红黑树，有序，不重复，关联容器，一对一key-value数据处理能力，O(lgn)查找，插入和删除
* multimap->红黑树，有序，可重复
* unordered_map->hash表，无序，不重复，O(1)查找
* unordered_multimap->hash表，无序，可重复，O(1)查找
* hash_set->hash表，无序，不重复
* hash_multiset->hash表，无序，可重复
* hash_map->hash表，无序，不重复
* hash_multimap->hash表，无序，可重复

### STL sort 机制
数据量大的时候采用**quick sort**，分段后的数据量小于某一个门槛时便采用**insertion sort**。

* 快排避免最差结果：

任何一个元素都可以被选做枢轴，比如随机选取，固定选取。但是划分的两端越均匀，执行效率越高；如果其中一段长度为0，那就出现了最坏情况。最理想的选取方法是选取头、尾和中间三个元素中大小处于中间的那个元素作为枢轴。这样可以避免出现最坏情况。

## 变量的声明和定义
* 声明

告诉编译器/解析器有这个变量存在，但是不分配内存空间
* 定义

为变量分配内存空间
* 初始化

创建变量的时候直接给与变量值，主要调用构造函数来完成

* 赋值

变量本身有值的时候对值进行修改，主要是通过赋值操作运算符来完成

## const
### const 的作用
变量保护。变量不允许被改变。可以修饰变量，参数，返回值，函数。
```
const int a=1; int const a=1;
const char *p：指针指向的内容不能改变
char *const p：指针保存的地址不能改变
const char * const p：指针保存的地址和指针指向的内容都不能改变
void function(const int a);
void function(const char* a);（指针指向的内容不能改变）
void function(char *const a);（指针保存的地址不能改变）
void function(const int& a);（引用参数在函数被不可改变）
```
class中任何不需要修改的成员函数和变量都应该声明为const
### const的实现机制
* 被修饰的常量是基本类型：程序在编译时，就把变量用常量替换了
* 被修饰的常量是非基本类型：程序编译时，不知道改用什么值替换再编译，所以用一块内存地址替换，再编译

## static
### static 的作用
隐藏。同时编译多个文件时，素有未加static前缀的全局变量和函数都有全局可见性。
保持。存储在静态数据区的变量会在程序刚开始运行的时候就完成初始化，也是唯一一次初始化。static默认初始化为0。
static修饰的变量或函数属于类，所有对象只有一份拷贝。
全局生命周期。static修饰的变量或函数属于类，所有对象只有一份拷贝。
### static 的用法
static函数不接收this指针，只能访问类的static成员变量。
* 静态变量：属于类，内存中只有一个实例，当类被加载，就会为该静态变量分配内存空间，和类一起存放在方法去中永远不会被回收，直到JVM退出
* 静态方法：属于类，和类一起存放在内存中，永远不会被回收，直到JVM退出。非静态方法需要实例调用，静态方法直接用类名调用
* 静态代码块：初始化一些不变的属性
* 静态内部类：加强代码可读性，多个外部类的对象可以共享同一个静态内部类的对象，静态内部类无需依赖于外部类。
* 静态导入
## volatile
是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，包括操作系统，硬件或者其它线程。
遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。
当要求使用volatile声明的变量的值，系统总是重新从他所在的内存读取数据，读取的数据立刻被保存。

volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。
而优化做法是，由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。
这样以来，如果 i是一个寄存器变量或者表示一个端口数据就容易出错，所以说 volatile 可以保证对特殊地址的稳定访问。

## sizeof
sizeof 是运算符，编译器推断出sizeof对象的类型，并把它当作常量处理。
### sizeof 类的大小
* **空类**，则值为1。

空类型实例中不包含任何信息，应该大小为0。但是当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例。至于占用多少内存，由编译器决定。g++中每个空类型的实例占1字节空间。注意空struct即空类，这就是为什么c++的空struct占一个字节的原因。
* **非空的类**，考虑字节对齐（变量必须以变量大小的整数倍地址作为起始地址）。

实例化的时候变量的地址都相同。**静态数据成员**放在全局数据成员中，它不占类实例大小，多个类实例只有一个实体。可以看作是一种特殊的全局变量。
* **存在虚函数的类**，产生一个指向虚函数表的指针Vptr，vptr放在类成员的最前面，大小为4;普通成员函数不占大小。
* **普通继承类**，子类大小+父类大小
* **虚函数继承类**，子类重用父类vptr，省去1个vptr空间

*注意：不同编译器选择的继承策略不同，也会导致sizeof大小不同。*
### sizeof 和 strlen 的区别
* sizeof(指针)=4；s
* sizeof(数组名)=数组大小；
* strlen(数组名)=字符串的长度

## 头文件 ifndef,define,endif
### 头文件的作用
* 加强类型检查，避免类型重复，提高类型安全；
* 减少公用代码的重复书写，提高编程效率；
* 提供保密和代码重用的手段。
### 头文件的类型
* 系统头文件<.h>
* 自定义头文件".h"
## 析构函数
### 继承层次中，为什么基类析构函数是虚函数
在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生。
如果基类析构函数不是虚函数，这样的删除只能够删除基类对象，不能删除子对象，造成内存泄漏。
在公有继承中，基类对派生类及其对象的操作，只能影响到那些从基类继承下来的成员。
如果想要用基类对非继承成员进行操作，就要把基类中的这个函数定义为虚函数。
### 什么情况下应该定义析构函数为虚函数
如果确定程序中有基类指针指向派生类的问题，则必须将基类的析构函数定义为虚函数，如此才能确保new出来的对象被正确delete
如果不需要基类对派生类及其对象进行操作，则不能定义虚函数，
因为定义虚函数的时候，编译器会给类添加虚函数表，存放虚函数指针，增加类的存储空间。
## 重载 overload 重写 override 隐藏 overwrite
### overload
将语义，功能相似的几个函数用同一个名字表示，但参数或返回值不同（包括类型，顺序不同）。

要求：相同的范围（在同一个类中），函数名字相同，参数不同，virtual关键字可有可无
### override
派生类函数覆盖基类函数

要求：不同的范围（分别位于派生类和基类），函数名字相同，参数相同，
基类函数必须有virtual关键字（基类会自动转换成virtual，写上virtual提高代码可读性）
### overwrite
隐藏，派生类的函数屏蔽了与其同名的基类函数

要求：不同的范围（分别位于派生类和基类），函数名字相同，参数不同时，基类函数被隐藏（于overload不同），
参数相同时，如果基类函数没有virtual关键字，基类函数被隐藏（于override不同）

## 锁
互斥锁，条件变量，自旋锁，读写锁
## 单例模式

##内存泄漏
