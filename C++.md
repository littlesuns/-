# C++
---
## 三大特性
* 封装

把客观事物封装成抽象的类，把自己的数据和方法只让可信的类或者对象操作，对不可信的类或者对象进行**信息隐藏**。

对象对内部数据提供了**不同级别的保护**，防止程序对数据进行错误的操作。

* 继承

使用已有的对象作为基类，在此基础上派生出新类。派生类可以复用基类的功能，也可以扩展，实现代码复用。可以通过继承和组合来实现。
### 实现方式
* 实现继承

直接使用基类的属性和方法，无需额外编码的能力

* 接口继承

仅使用属性和方法的名称，但是子类必须提供实现的能力

* 多态

## 多态
一个类实例的相同方法在不同情形下有不同的表现形式。分为编译时多态和运行时多态。编译时多态叫做重载，运行时多态主要指动态绑定。基类的指针和引用可以调用派生类的指针或引用。
### 多态的实现方式
* 静态多态

同名函数，不同参数，编译器会根据实参类型来选择调用合适的函数，如果没有合适的函数就会发出警告或者报错。
* 动态多态

类，虚函数。
### 虚函数
当类中存在虚函数，编译器会在类中自动生成一个虚函数表，虚函数表是一个存储类成员函数指针的数据结构。

virtual修饰的成员函数会被编译器放入虚函数表。

编译器会为对象自动生成一个指向虚函数表的指针（vptr指针）。

当我们传入父类对象时，将调用和执行父类的函数，当我们传入子类对象时，将调用和执行子类的函数。

而 C++ 编译器的执行过程其实是这样的：
父类的 fun() 是个虚函数，所以编译器给父类对象自动添加了一个 vptr 指针，指向父类的虚函数表，
这个虚函数表里存放了父类的 fun() 函数的函数指针。

子类的 fun() 函数是重写了父类的，即写不写 virtual 编译器都会为其自动添加一个 virtual，
然后编译器给子类对象自动添加了一个 vptr 指针，指向子类的虚函数表，这个虚函数表里存放了子类的 fun() 函数的函数指针。

执行 p->fun() 时，编译器检测到 fun() 是一个虚函数，所以不会静态的将 Parent 类的 fun() 方法直接编译过来，
而是是运行的时候，动态的根据 base 指向的对象，找到这个对象的 vptr 指针，然后找到这个对象的虚函数表，
最后调用虚函数表里对应的函数，实现多态。

### 如何证明vptr的存在
* 存在vptr的类，size增加了4个字节
* 父类的构造方法中调用虚函数，不会发生多态

### vptr 的分步初始化
在父类中调用虚函数时，执行的还是父类的函数，没有发生多态。这是因为当创建子类对象时，编译器的执行顺序其实是这样的：
* 对象在创建时，由编译器对 vptr 进行初始化
* 子类的构造会先调用父类的构造函数，这个时候 vptr 会先指向父类的虚函数表
* 子类构造的时候，vptr 会再指向子类的虚函数表
* 对象的创建完成后，vptr 最终的指向才确定

### 构造函数中调用虚函数
* 当在构造函数中调用虚函数时，虚函数表现为该类中虚函数的行为，即父类构造函数调用虚函数，则虚函数为父类中的虚函数；
子类构造函数中调用虚函数，则调用的是子类中的虚函数；
* 如果不是在构造函数中调用虚函数，则会首先查看虚函数表，如果有实例实现，则调用实例。
比如：父类中有虚函数watchTv，则调用父类中watchTv时，则因为子类实现了watchTv，则调用子类的watchTv。

### 纯虚函数
* 当想在基类中抽象出一个方法，且该基类只做能被继承，而不能被实例化；
* 这个方法必须在派生类(derived class)中被实现。
```
class CShape
{
public:
    virtual void Show()=0;
};
```
### 虚继承
一个指定的基类，在继承体系结构中，将其成员数据实例共享给也从这个基类型直接或间接派生的其它类。这一概念一般用于“继承”在表现为一个整体，而非几个部分的组合时。在C++中，基类可以通过使用关键字virtual来声明虚继承关系。
#### 菱形继承
假如类A和类B各自从类X派生（非虚继承且假设类X包含一些数据成员），且类C同时多继承自类A和B，那么C的对象就会拥有两套X的实例数据（可分别独立访问，一般要用适当的消歧义限定符），产生多重继承歧义。
#### 虚继承解决多重继承歧义
如果类A与B各自虚继承了类X，那么C的对象就只包含一套类X的实例数据，避免由于带有歧义的组合而产生的问题。其原理是，间接派生类（C）穿透了其父类（上面例子中的A与B），实质上直接继承了虚基类X。
```
class A
{
public:
	A():a(1){};
	void printA(){cout<<a<<endl;}
	int a;
};
 
class B : virtual public A
{
};
 
class C : virtual public A
{
};
 
class D:  public B ,  public C
{
};
 
int _tmain(int argc, _TCHAR* argv[])
{
	D d;
	cout<<sizeof(d);
	d.a=10;
	d.printA();

```

## 派生类向基类转换
* public继承：用户代码和后代类均可以使用派生类到基类的转换；
* protected 继承：用户代码不可以使用派生类到基类的转换，派生类其后代可以；
* private继承，用户代码和派生类的后代不可以，派生类自身可以。

## 变量的声明和定义
* 声明

告诉编译器/解析器有这个变量存在，但是不分配内存空间
* 定义

为变量分配内存空间
* 初始化

创建变量的时候直接给与变量值，主要调用构造函数来完成

* 赋值

变量本身有值的时候对值进行修改，主要是通过赋值操作运算符来完成
## 指针和引用
* 指针

是一个存储地址的变量，指向内存的一个存储单元
* 引用

原变量的别名，和原变量是同一个东西
```
int a=1;int *p=&a;
int a=1;int &b=a;
```
### 区别
* 指针是一个存储变量地址的变量，引用是变量的别名；
* 可以有const指针，但是没有const引用；
* 指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）
* 指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；
* 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了；
* "sizeof引用"得到的是所指向的变量(对象)的大小，而"sizeof指针"得到的是指针本身的大小；
* 指针和引用的自增(++)运算意义不一样。

### 左值引用& 右值引用&&
* 左值存放在对象中，有持久的状态；右值要么是字面常量，要么是在表达式求值过程中创建的临时对象，没有持久的状态。
* 在大多数情况下，需要右值的地方可以用左值来替代，但需要左值的地方，一定不能用右值来替代。
```
int& bar = foo; //左值引用
int&& qux = 42; //右值引用
```
C++ 11 支持引用叠加
```
Type&  &  -> Type&
Type&  && -> Type&
Type&& &  -> Type&
Type&& && -> Type&&
```
#### 右值引用的使用场景
右值引用的主要目的是：
* 消除两个对象交互的时候不必要的拷贝，直接进行控制权的转移，提高效率；
* 能够间接明确的定义泛型函数。
* 右值引用用来支持移动构造函数和移动赋值函数；移动构造函数可以获取其他指针变量对内存空间的支配权，针对浅拷贝的操作，常常将原指针的内存空间由现在的指针进行替换，将原指针指向NULL。
* 右值引用可以用来延长临时变量的生存期；

## 动态绑定
### 对象类型
* 对象的静态类型：对象在声明时采用的类型。是在编译期确定的。
* 对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。
### 绑定
* 静态绑定：绑定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译期，类型不能更改；
* 动态绑定：绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期，类型可以更改；
* 要想实现动态，必须使用动态绑定；
* 在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；
* 绝对不要重新定义继承而来的非虚(non-virtual)函数，因为它是静态绑定，无法实现多态，还会埋下未知的bug。
* 绝对不要重新定义一个继承而来的virtual函数的缺省参数值，因为缺省参数值都是静态绑定（为了执行效率），而virtual函数却是动态绑定。
```
D* pD = new D();//pD的静态类型是它声明的类型D*，动态类型也是D*
B* pB = pD;//pB的静态类型是它声明的类型B*，动态类型是pB所指向的对象pD的类型D*
C* pC = new C();
pB = pC;//pB的动态类型是可以更改的，现在它的动态类型是C*
```

## 内存管理
### 内存分配
全局变量区：全局变量和静态变量。
常量存储区：常量。
代码存放区：函数体的二进制代码
栈：局部变量，函数参数等。由编译器自动分配和清除。地址从高到低分配。
堆：由用户分配和释放。如果用户不释放，程序结束时可能由操作系统回收。

### 堆和栈的区别
* 管理方式不同；栈由编译器自动管理，堆由用户控制，容易产生内存泄露。
* 分配效率不同；栈由系统自动分配，效率较高。
* 空间大小不同；栈默认大小1-2M，堆32位系统可达4G。
* 能否产生碎片不同；栈不会产生碎片，堆会。
* 生长方向不同；栈地址从高位到低位分配，堆地址从低位到高位分配。
* 存储内容不同：函数进栈时，第一个进栈的是主函数中的吓一跳指令的地址，然后是函数的各个参数从右往左入栈，然后是函数中的局部变量。静态变量不入栈。堆的头部用一个字节存放堆的大小，堆中的具体内容由用户安排。
### new 和 malloc 的区别
* new

是一个操作符，它也可以完成分配一段内存空间的功能，除此之外，它还会对内存空间进行初始化，调用构造函数。

* malloc

是一个函数，可以分配一段内存空间，并返回地址的指针。
### malloc 底层机制
malloc 采用了**内存池**的方式来减少内存碎片和系统调用的开销。

先申请大块内存作为堆区，然后将堆分成许多内存块，以块为内存管理的基本单位。Malloc通过**隐式链表结构**来管理所有的空闲块，即用一个双向链表将空闲块连接起来，每一个空闲块记录里一个连续的未分配的地址。

当用户申请内存的时候，直接从堆区分配出一块适合的空闲块。当进行内存分配的时候，Malloc 会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配。Malloc 在申请内存的时候，一般会通过**brk 和 Mmap** 系统调用进行申请。当内存数量小128k采用前者，否则采用后者。

当进行内存合并的时候，malloc 采用**边界标记法**，根据每个块是否已经分配来决定是否进行块合并。
* 前后都已被占用：直接插入内存块
* 前后至少有一个没有被占用：先合并再插入

### 堆的碎片问题
* 内部碎片：内存分配太多，一部分分配出去的内存没有用上
* 外部碎片：碎片太小

解决方法：
* 内存池：一次性申请足够大的空间，在内存池上进行管理。
* 空间大小：每次申请的空间大小尽量取2的指数。
* 避免使用动态分配函数。

### 使用动态内存的场景
* 程序不知道需要使用多少个变量
* 程序不知道变量的类型
* 程序需要共享一段数据

### 内存泄露
程序分配了一块内存，但已经不再持有引用这块内存的对象（通常是指针），虽然这些内存被分配出去，但是无法收回，将无法被其他的进程所使用，我们说这块内存泄漏了，被泄漏的内存将在整个程序声明周期内都不可使用。

主要原因：使用new或malloc动态分配堆上的内存空间，而并未使用delete或free及时释放掉内存。

常见错误：
* malloc和free未成对出现
* 通过局部分配的内存，未在调用者函数体内释放（因为内存分配与释放是在不同的函数体内）
* 在局部分配的内存未释放，局部函数结束后，程序失去对该内存的控制—出现段错误
* New delete未成对出现，或者delete [] 不匹配
* delet void * 的指针，导致没有调用到对象的析构函数，析构的所有清理工作都没有去执行从而导致内存的泄露；
* 没有将基类的析构函数定义为虚函数，当基类的指针指向子类时，delete该对象时，不会调用子类的析构函数

### delete p 和 delete []p 的区别
New 和delete都有两个版本
```
void* operator new (size_t);        // allocate an object
void* operator new [] (size_t);     // allocate an array
void operator delete (void*);       // free an oject
void operator delete [] (void*);    // free an array
```
如果对象无析构函数（包括不需要合成析构函数，比如注释掉~A和string s两行代码），
delete会直接调用operator delete并直接调用free释放内存。
这个时候的new=new [](仅在数量上有差异)，delete=delete[]。

如果对象存在析构函数（包括合成析构函数），则：
new []返回的地址会后移4个字节，并用那4个存放数组的大小!而new不用后移这四个字节。
delete[]根据那个4个字节的值，调用指定次数的析构函数 ，同样delete也不需要那四个字节。
```
delete []objects; // 正确的用法
delete objects;  // 错误的用法
```
后者相当于delete objects[0]，漏掉了另外99 个对象。

严格应该这样说：后者相当于仅调用了objects[0]的析构函数，漏掉了调用另外99 个对象的析构函数，并且在调用之后释放内存时导致异常（如果存在析构函数的话），如果对象无析构函数该语句与delete []objects相同

## 智能指针
### 为什么要用智能指针
malloc/new的缺陷：
* 手动malloc/new出来的资源，容易忘记free/delete
* 影响执行流的地方需要注意释放释放资源，容易导致资源泄漏（如free/delete在return之后）
* 中途抛出异常，无法释放资源。如：int*p1=new int；int*p2=new int [10000000]；delete p1;
delele [ ] p2;因为p2new的内存比较大，万一new失败，则导致p1永远无法释放。

创建一份资源出来的时候，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源。
除此之外，通过运算符重载（重载和重等），可以向指针一样使用。
### 智能指针类型
* Shared_ptr 

是一种智能指针，它在构造函数期间进行动态内存分配，在析构函数进行内存的释放。

它是一种可共享的指针，即多个指针可以同时指向一个对象。

类中存在一个引用的计数器。当增加一个指向同一个对象的指针的时候，计数器加一，否则减一。当计数器的值为零的时候，会将内存进行释放。
* Unique_ptr 

是一种独占的智能指针，一个对象只能有一个Unique_ptr进行指向。在进行指针复制的时候需要进行先提前释放指针指向的对象。
* Weak_ptr

是一种智能指针。它可以指向一个由Shared_ptr 所指向的对象。借此可以得到shared_ptr 指针的数目。
它本身指向对象并不会增加指针指向数目的增加。可以通过该方式解决智能指针的内存泄漏的问题。

## 强制转换
### const_cast
常量指针/引用被转换成非常量的指针/引用，并指向原来的对象。
使用它来去除const引用对象的const，完成函数调用。

结合static_cast，在非const版本的成员函数中添加const，调用完const版本的成员函数后，再使用const_cast去除const限定
### static_cast
用于基本数据类型之间的转换，安全性需要开发者来维护

类层次结构中基类和派生类之间指针或引用的转换。上行转换（派生类的指针转换成基类表示）是安全的，下行转换是不安全的。

C++的任何的隐式转换都是使用static_cast实现的。

没有运行时类型检查来保证转换的安全性，所以有安全隐患。

static_cast不能转换掉原有类型的const，volatile，_unaligned属性，但前两者可以使用const_cast去除。
### dynamic_cast
存在虚函数的父子关系的强制类型转换，对于指针，转换失败返回nullptr，对于引用，失败会抛出异常
### reinterpret_cast
在底层进行位操作的强制的类型转换，不保证安全。

## STL
### STL容器的底层数据结构及时间复杂度
* vector->数组，O(1)时间访问，顺序存储，扩容规则：初始分配连续内存空间，空间满后重新申请2倍内存空间，拷贝，释放原空间
* list->双向链表
* deque->中央控制器+多个缓冲区，支持首尾快速增删，支持随机访问
* stack->list或者deque
* queue->list或者deque
* priority_queue->vector为底层容器，heap为处理规则，O(1)取出最大最小元素，O(lgn)插入和删除
* set->红黑树，有序，不重复，只保存key，不保存value
* multiset->红黑树，有序，可重复
* map->红黑树，有序，不重复，关联容器，一对一key-value数据处理能力，O(lgn)查找，插入和删除
* multimap->红黑树，有序，可重复
* unordered_map->hash表，无序，不重复，O(1)查找
* unordered_multimap->hash表，无序，可重复，O(1)查找
* hash_set->hash表，无序，不重复
* hash_multiset->hash表，无序，可重复
* hash_map->hash表，无序，不重复
* hash_multimap->hash表，无序，可重复

### STL sort 机制
数据量大的时候采用**quick sort**，分段后的数据量小于某一个门槛时便采用**insertion sort**。

* 快排避免最差结果：

任何一个元素都可以被选做枢轴，比如随机选取，固定选取。但是划分的两端越均匀，执行效率越高；如果其中一段长度为0，那就出现了最坏情况。最理想的选取方法是选取头、尾和中间三个元素中大小处于中间的那个元素作为枢轴。这样可以避免出现最坏情况。

## const
### const 的作用
变量保护。变量不允许被改变。可以修饰变量，参数，返回值，函数。
```
const int a=1; int const a=1;
const char *p：指针指向的内容不能改变
char *const p：指针保存的地址不能改变
const char * const p：指针保存的地址和指针指向的内容都不能改变
void function(const int a);
void function(const char* a);（指针指向的内容不能改变）
void function(char *const a);（指针保存的地址不能改变）
void function(const int& a);（引用参数在函数被不可改变）
```
class中任何不需要修改的成员函数和变量都应该声明为const
### const的实现机制
* 被修饰的常量是基本类型：程序在编译时，就把变量用常量替换了
* 被修饰的常量是非基本类型：程序编译时，不知道改用什么值替换再编译，所以用一块内存地址替换，再编译

### const #define 的区别
* 编译器处理方式不同

宏常量在预处理阶段展开；const常量在编译运行阶段使用
* 类型和类型安全检查

const常量有数据类型，在编译阶段会进行类型安全检查；宏常量没有数据类型，不进行类型安全检查，只进行字符替换
* 能否调试

有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试
* 存储方式不同 

宏常量在预处理阶段展开，不分配内存；const常量分配内存

## static
### static 的作用
隐藏。同时编译多个文件时，素有未加static前缀的全局变量和函数都有全局可见性。
保持。存储在静态数据区的变量会在程序刚开始运行的时候就完成初始化，也是唯一一次初始化。static默认初始化为0。
static修饰的变量或函数属于类，所有对象只有一份拷贝。
全局生命周期。static修饰的变量或函数属于类，所有对象只有一份拷贝。
### static 的用法
static函数不接收this指针，只能访问类的static成员变量。
* 静态变量：属于类，内存中只有一个实例，当类被加载，就会为该静态变量分配内存空间，和类一起存放在方法去中永远不会被回收，直到JVM退出
* 静态方法：属于类，和类一起存放在内存中，永远不会被回收，直到JVM退出。非静态方法需要实例调用，静态方法直接用类名调用
* 静态代码块：初始化一些不变的属性
* 静态内部类：加强代码可读性，多个外部类的对象可以共享同一个静态内部类的对象，静态内部类无需依赖于外部类。
* 静态导入

## volatile
是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，包括操作系统，硬件或者其它线程。
遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。
当要求使用volatile声明的变量的值，系统总是重新从他所在的内存读取数据，读取的数据立刻被保存。

volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。
而优化做法是，由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。
这样以来，如果 i是一个寄存器变量或者表示一个端口数据就容易出错，所以说 volatile 可以保证对特殊地址的稳定访问。

## sizeof
sizeof 是运算符，编译器推断出sizeof对象的类型，并把它当作常量处理。
### sizeof 类的大小
* **空类**，则值为1。

空类型实例中不包含任何信息，应该大小为0。但是当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例。至于占用多少内存，由编译器决定。g++中每个空类型的实例占1字节空间。注意空struct即空类，这就是为什么c++的空struct占一个字节的原因。
* **非空的类**，考虑字节对齐（变量必须以变量大小的整数倍地址作为起始地址）。

实例化的时候变量的地址都相同。**静态数据成员**放在全局数据成员中，它不占类实例大小，多个类实例只有一个实体。可以看作是一种特殊的全局变量。
* **存在虚函数的类**，产生一个指向虚函数表的指针Vptr，vptr放在类成员的最前面，大小为4;普通成员函数不占大小。
* **普通继承类**，子类大小+父类大小
* **虚函数继承类**，子类重用父类vptr，省去1个vptr空间

*注意：不同编译器选择的继承策略不同，也会导致sizeof大小不同。*
### sizeof 和 strlen 的区别
* sizeof(指针)=4；s
* sizeof(数组名)=数组大小；
* strlen(数组名)=字符串的长度

## 头文件 ifndef,define,endif
### 头文件的作用
* 加强类型检查，避免类型重复，提高类型安全；
* 减少公用代码的重复书写，提高编程效率；
* 提供保密和代码重用的手段。
### 头文件的类型
* 系统头文件<.h>
* 自定义头文件".h"
## 构造函数
以类名作为函数名，无返回类型。当该类对象被创建时，编译系统为对象分配内存空间，并自动调用该构造函数，完成初始化。

构造函数不能声明为虚函数的原因：
* 构造函数需要一个明确的构造类型
* 虚函数要对应虚函数表，执行构造函数的时候还没有实例，找不到虚函数表。
### 构造函数顺序
基类的构造函数->成员类的构造函数->成员类对象在类中声明的顺序->派生类的构造函数

### 构造函数类型
#### 无参数构造函数
* 如果创建了一个类没有写任何构造函数，系统会自动生成默认的无参数构造函数。
* 如果写了其他类型的构造函数，系统就不会自动生成无参数构造函数。如果希望有，就需要自己显式地写出来。
#### 一般构造函数（重载构造函数）
一个类可以有多个一般构造函数，每个一般构造函数的参数形式不同。基于C++的函数重载。
```
Complex(double real)
        {
             m_real = real;
	     m_imag = 0.0;  
         } 
Complex(double real, double imag)
        {
             m_real = real;
             m_imag = imag;        
         } 
```
#### 拷贝构造函数
参数是类对象本身的引用，根据一个已存在的对象复制出一个新的该类的对象。如果没有显式地写出来，系统会默认创建一个（浅）拷贝构造函数。当类中有成员指针，系统默认创建的拷贝构造函数会存在风险。

拷贝构造函数发生的情况：
* 用=定义变量的时候
* 将一个对象作为实参值传递给一个非引用的形参的时候 
* 将一个函数的非引用返回值返回给一个对象的时候
* 用{}初始化一个数组的元素或成员的时候

```
Complex(const Complex & c)
        {
                m_real = c.m_real;
                m_imag    = c.m_imag;
        }     
```
#### 类型转换构造函数
根据一个指定的类型的对象创建一个本类的对象。
```
Complex(double r)
        {
                m_real = r;
                m_imag = 0.0;
        }
```
#### 等号运算符重载（赋值构造函数）
将等号右边的本类对象的值复制给等号左边的对象。
不属于构造函数，等号左右两边的对象必须已经被创建。
如果没有显式地写等号，系统会创建一个默认的等号运算符重载，做一些基本的拷贝工作。
```
Complex &operator=( const Complex &rhs )
{
	// 首先检测等号右边的是否就是左边的对象本身，若是本对象本身,则直接返回
	if ( this == &rhs )
	{
		return *this;
	}               
	// 复制等号右边的成员到左边的对象中
	this->m_real = rhs.m_real;
	this->m_imag = rhs.m_imag;               
	// 把等号左边的对象再次传出
	// 目的是为了支持连等 eg:    a=b=c 系统首先运行 b=c
	// 然后运行 a= ( b=c的返回值,这里应该是复制c值后的b对象)    
	return *this;
	}
};
```
### 深拷贝 浅拷贝
* 浅拷贝

将被拷贝对象的数据成员的值一一赋值给新创建的对象。

如果该类的数据成员中有指针成员，新的对象的指针和被拷贝对象的指针指向同一个地址，delete该指针时会导致两次重复delete而出错。
* 深拷贝

指针拷贝时，重新申请一块内存给新的对象的指针数据成员。
```
class Person
{
public :
         // 构造函数
        Person(char * pN)
        {
              cout << "一般构造函数被调用 !\n";
              m_pName = new char[strlen(pN) + 1];
              //在堆中开辟一个内存块存放pN所指的字符串
              if(m_pName != NULL)
              {
                 //如果m_pName不是空指针，则把形参指针pN所指的字符串复制给它
                   strcpy(m_pName ,pN);
              }
        }        
       
        // 系统创建的默认复制构造函数，只做位模式拷贝
        Person(Person & p)    
        {
                  //使两个字符串指针指向同一地址位置        
                 m_pName = p.m_pName;        
        }
         ~Person( )
        {
                delete m_pName;
        }
  private :

        char * m_pName;
};

void main( )
{
        Person man("lujun");
        Person woman(man);
       
        // 结果导致   man 和    woman 的指针都指向了同一个地址
       
        // 函数结束析构时
        // 同一个地址被delete两次
}
// 下面自己设计复制构造函数，实现“深拷贝”，即不让指针指向同一地址，而是重新申请一块内存给新的对象的指针数据成员
Person(Person & chs);
{
         // 用运算符new为新对象的指针数据成员分配空间
         m_pName=new char[strlen(p.m_pName)+ 1];

         if(m_pName)        
         {
                 // 复制内容
                strcpy(m_pName ,chs.m_pName);
         }
     
        // 则新创建的对象的m_pName与原对象chs的m_pName不再指向同一地址了
}
```
*注意:显式调用构造函数无法实现给私有成员赋值的目的。*

## 析构函数
### 继承层次中，为什么基类析构函数是虚函数
在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生。
如果基类析构函数不是虚函数，这样的删除只能够删除基类对象，不能删除子对象，造成内存泄漏。
在公有继承中，基类对派生类及其对象的操作，只能影响到那些从基类继承下来的成员。
如果想要用基类对非继承成员进行操作，就要把基类中的这个函数定义为虚函数。
### 什么情况下应该定义析构函数为虚函数
如果确定程序中有基类指针指向派生类的问题，则必须将基类的析构函数定义为虚函数，如此才能确保new出来的对象被正确delete
如果不需要基类对派生类及其对象进行操作，则不能定义虚函数，
因为定义虚函数的时候，编译器会给类添加虚函数表，存放虚函数指针，增加类的存储空间。
### 析构函数中不能抛出异常
如果对象在运行期间出现了异常，C++异常处理模型需要清除这个由于出现异常而导致的已经失效的对象，并释放对象原来所分配的资源。这就是调用对象的析构函数来完成释放资源的任务。析构函数做为异常处理的一部分。必须要保证自身是安全的。

## 重载 overload 重写 override 隐藏 overwrite
### overload
将语义，功能相似的几个函数用同一个名字表示，但参数或返回值不同（包括类型，顺序不同）。

要求：相同的范围（在同一个类中），函数名字相同，参数不同，virtual关键字可有可无
### override
派生类函数覆盖基类函数

要求：不同的范围（分别位于派生类和基类），函数名字相同，参数相同，
基类函数必须有virtual关键字（基类会自动转换成virtual，写上virtual提高代码可读性）
### overwrite
派生类函数覆盖基类函数

要求：不同的范围（分别位于派生类和基类），函数名字相同，参数可同可不同，必须加上virtual
### 调用隐藏的基类函数
* using

该方法只适用于被隐藏的基类函数，在派生类的类定义中使用using A::f，就把基类中的所有f()的重载版本包含进来了。
* 作用域运算符

m.A::f()，访问被派生类覆盖了的成员变量只能用这种方法
## size_t
size_t 类型定义在cstddef头文件中,该文件是C标准库的头文件stddef.h的C++版。 它是一个与机器相关的unsigned类型，其大小足以保证存储内存中对象的大小。
## Nullptr 和 NULL
Nullptr 是一个空的指针，在c++中，NULL指的是0。

## 字符串常量
* 如果指针指向相同的字符串常量的话，这些指针会指向相同的地址；
* 如果是数组用常量字符串初始化的话，这些数组会被分配到不同的空间。

## 堆和栈的区别
存储内容
系统响应
内存限制
申请效率
存取效率
### 定义只能在堆/栈上生成的对象
#### 只能在堆上
方法：将析构函数设置为私有

原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。
若析构函数不可访问，则不能在栈上创建对象。
#### 只能在栈上
方法：将 new 和 delete 重载为私有

原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；
第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。

## 调用
### 函数调用过程
* 建立栈空间；
* 保护现场，主调函数运行状态和返回地址入栈；
* 为被调函数的局部变量分配空间，完成参数传递；
* 执行被调函数的函数主体；
* 释放被调函数的栈空间
* 恢复现场，取主调函数运行状态和返回地址，释放栈空间；
* 继续执行主调函数任务。
### 静态成员函数如何调用非静态成员变量
* 在静态函数的形参表里加上实例的地址
```
class A
{
public:
    static void test(A *a)
    {
        a->m_a += 1;
    }
private:
    int m_a
};
```
* 放上全局变量地址
* 在静态函数的形参表里加上一个内存首地址
```
class A
{
public:
    static void test(void *pData)
    {
        A *a = (A *)pData;
        a->m_a += 1;
    }
private:
    int m_a
};
A a;
test(&a);
```

### 回调函数
回调函数就是一个通过函数指针调用的函数，如果把函数的指针作为参数传递给另一个函数，当这个指针被用来调用其所执行的函数的时候，称这个为回调函数。

C++的类成员函数不能像普通函数那样用于回调，因为每个成员函数都需要有一个对象实例去调用它。因此只能把其设置为静态成员函数。通过传入地址的方式来解决调用非静态成员变量的问题。

### C C++ 相互调用
* C++ 调用 C：使用extern "C"；
```
extern "C" {
#include "CFile.h"
}
```
* C调用C++：提供一个调用的 cpp 中间件。

## 模板 泛型
为了做基于类型和常量的编译时多态

编译时多态类型：
* 模板
* 函数（操作符）重载--动态多态
* 模板特化：全特化-特化后不再有模板参数，部分特化-特化后仍然有模板参数
* duck typing：基于特征的多态方式
## 字节
### 字节序
储存数据的方式：大端字节序（高位在前，低位在后），小端字节序（高位在后，低位在前）

为什么会有小端字节序：计算机电路先处理低位字节，效率高，因为计算都是从低位开始。

所以计算机内部可能会用小端字节序（X86是小字节序）(不知道能不能改变）

什么时候用大端字节序：网络传输和文件存储。符合人类读写习惯
### 字节对齐
计算机存储系统以byte为单位存储数据，不同数据类型所占空间不同。默认情况下将数据存放在某个地址的起始位置，这个地址能够被数据类型大小整除。
例如int的起始地址能被4整除。
结构体变量的首地址能够被其最宽基本类型成员的大小所整除；
结构体每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节（internal padding）；
结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）。
便于计算机快速读写数据。
```
struct student{char name[5],int num,short score;}=>16字节
struct student{nt num,char name[5],short score;}=>12字节
```
可以使用pragma pack（2），手动设置数据类型大小大于2的都按2字节对齐

## 程序的运行
### 预处理
* 将所有的宏定义展开；
* 将所有的条件预编译指令进行处理
* 将包含的文件插入到预编译的指令位置处
* 处理//  、/* */ 等符号。 Gcc – E hello world .cpp  -o hello world.i 

### 汇编
将预处理完的文件进行一系列的词法分析、语法分析、以及优化之后产生相应的汇编代码文件。是将高级语言翻译成机器语言的一个工具。

 G++ -S helloworld.i –o helloworld.s

### 链接
将每个源代码独立的进行编译，然后按照要求将他们组装起来，这个组装模块的过程叫做链接。

#### 静态链接

对库函数的连接是放在编译时期完成的叫静态链接，所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。程序在运行时，与链接库没有关系。因为所有的函数已复制到相关位置，这些库叫做静态链接库。

#### 动态链接

一些库函数的链接载入推迟到程序的运行时期，这叫做动态链接库。

#### 比较
* 动态链接库有助于进程间的资源共享 ；动态链接库可以在内存中被所有运行的进程所共享。
* 将一些程序升级变化的简单。用静态库 如果库发生变化，使用库的文件需要重新编译。使用动态库则可以直接修改动态库就可以，程序本身不需要改变。
* 静态链接库由于在编译过程中已经被装载到程序中去了，而动态链接库必须在运行的时候再装载，所以程序在执行过程中，用静态库速度更快些。

## 锁
互斥锁，条件变量，自旋锁，读写锁
## 单例模式

##内存泄漏

## 哈希
### HashTable HashMap ConcurentHashMap
#### Hashtable
底层数组+链表实现，无论key还是value都不能为null，线程安全，实现线程安全的方式是在修改数据时锁住整个HashTable，效率低。

初始size为11，扩容：newsize = olesize\*2+1

计算index的方法：index = (hash & 0x7FFFFFFF) % tab.length
#### HashMap
底层数组+链表实现，可以存储null键和null值，线程不安全

初始size为16，扩容：newsize = oldsize\*2，size一定为2的n次幂

扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入。
插入元素后才判断该不该扩容，有可能无效扩容（插入后如果扩容，如果没有再次插入，就会产生无效扩容）。
当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀

计算index方法：index = hash & (tab.length – 1)
#### ConcurrentHashMap
底层采用分段的数组+链表实现，线程安全。

通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。)

Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术
有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。

扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容。

### 一致性哈希
一致性哈希算法常被用于负载均衡中要求资源被均匀分布到所有节点上，并且对资源的请求能快速路由到对应的节点。

hash算法进行缓存时，如果其中一台服务器故障或者需要增加新服务器，需要变动所有缓存的位置，非常不便。

做法是把对服务器数量取模改成对2^32取模。
